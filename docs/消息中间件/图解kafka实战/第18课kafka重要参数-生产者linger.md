# 1、linger 浮想

`linger`这个单词，很不错呢，想起来了平安的`宋玲歌`老师，虽然没见过她，也不知道是男是女，但是这个名字很好听。
应该是个可爱的女孩子，吧。

讲真的，linger表示`徘徊、缓慢度过、磨磨蹭蹭`。

# 2、生产者发送时间
我们知道，生产者有个消息累加器，里面有密密麻麻的 ProducerBatch，我们会在ProducerBatch被填满的情况下，发送消息。

那万一，迟迟填不满呢，卡住？ 那可不行，等待时间到了也要给我发出去。

这个等待时间的设置就是：`linger.ms`，默认是`5ms`。

说起来，优秀的设计总是相似的，想起了tcp的 `Nagle` 算法。（为什么我总叫他`尼哥算法`？？？）

## 2.1 tcp的nagle
先说明哈，翻译是`纳格算法`，不是`尼哥算法`。

nagle提出的`小数据包问题`：
```text
某个应用程序不断地提交小单位的资料，且某些常只占1字节大小。

因为TCP数据包具有40字节的标头信息（TCP与IPv4各占20字节），

这导致了41字节大小的数据包只有1字节的可用信息，造成庞大的浪费。
```

`小数据包问题`场景：
```text
这种状况常常发生于Telnet工作阶段－大部分的键盘操作会产生1字节的资料并马上提交。

更糟的是，在慢速的网络连线下，这类的数据包会大量地在同一时点传输，造成拥塞碰撞。
```

nagle算法：
```text
if有新資料要傳送
    if 訊窗大小 >= MSS and可傳送的資料>= MSS
        立刻傳送完整MSS大小的segment
    else
        if管線中有尚未確認的資料
            在下一個確認（ACK）封包收到前，將資料排進緩衝區佇列
        else
            立即傳送資料  
```
其中`MSS`是最大报文大小。

[维基百科](https://zh.wikipedia.org/wiki/%E7%B4%8D%E6%A0%BC%E7%AE%97%E6%B3%95) 关于nagle和TCP延迟确认冲突问题的解释：
```text
该算法与 TCP延迟确认 会有不好的相互作用，

例如当程序发送端进行两次连续的小段写再跟着读时，

接收端接收到第一次写后因TCP延迟确认而等待第二次写后一并发送ACK，

发送端则因第二次写数据长度小于MSS而等待第一次写的ACK（如上算法所示），

最终将导致两对端都进入等待直到ACK延迟超时。

因为这个原因，TCP实现通常为应用程序提供一个禁用Nagle算法的接口（通常称为TCP_NODELAY选项）。

用户级解决方案是避免套接字上的 写-写-读 序列。 

写-读-读 和 写-写-写 都是没问题的。但 写-写-读 则是性能杀手。

所以，如果可以的话，缓冲你对TCP的小段写，然后一次发送它们。在每次读之前使用标准的UNIX I/O包并冲刷写缓存通常能起作用。
```

不过nagle和linger的算法差异在于，当不满足数据发送大小时，nagle在等`对端的ACK`，kafka的生产者linger在`等时间`。