* **1、数据库的三大范式？**
* **2、事务隔离级别有哪些？**
* **3、索引是什么？**
* **4、常见的存储引擎有哪些？**
* **5、MVCC 实现原理？**
* **6、快照读和当前读？**
* **7、那么MySQL如何实现避免幻读？**
* **8、共享锁和排他锁**
* **9、大表怎么优化？**
* **10、MySQL 执行计划了解吗？**
* **11、bin log/redo log/undo log**
* **12、讲一下MySQL架构？**
* **13、分库分表?**
* **14、查询语句执行流程？?**
* **15、更新语句执行过程？？?**
* **16、exist和in的区别？？？?**
* **17、MySQL中int(10)和char(10)的区别？**
* **18、truncate、delete与drop区别？?**
* **19、having和where区别？**
* **20、什么是MySQL主从同步？**
* **21、乐观锁和悲观锁是什么？？？**
* **22、用过processlist吗？**

## **1、数据库的三大范式？**
* 第一范式1NF: 保证字段的原子性，比如“深圳 肥婆”，就必须分成两个字段“city”、“userName”。
* 第二范式2NF: 在满足第一范式的前提下，一是表`必须有一个主键`；二是所有的非主键列必须`完全依赖于主键`，而不能只依赖于主键的一部分。
  * 举个反例：假定选课关系表为StudentCourse(学号, 姓名, 年龄, 课程名称, 成绩, 学分)，主键为(学号, 课程名称)。其中学分完全依赖于课程名称，姓名年龄完全依赖学号，不符合第二范式。
  * 修改方案：可以拆分成三个表：学生：Student(学号, 姓名, 年龄)；课程：Course(课程名称, 学分)；选课关系：StudentCourseRelation(学号, 课程名称, 成绩)。
* 第三范式3NF: 在满足第二范式的前提下，另外非主键列必须直接依赖于主键，`不能存在传递依赖`。
  * 即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。
  * 举个反例：学生关系表为Student(学号, 姓名, 年龄, 学院id, 学院地点, 学院电话)，主键为"学号"，其中学院id依赖于学号，而学院地点和学院电话依赖于学院id，存在传递依赖，不符合第三范式。
  * 修改方案：可以把学生关系表分为如下两个表：学生：(学号, 姓名, 年龄, 学院id)；学院：(学院,id 地点, 电话)。
* 第二和第三的区别：
  * 第二强调非主键列依赖主键的全部，而不是其中的一部分，如果有5个非主键列，那么这5个非主键列`所有都要`依赖主键，而且`不能只依赖主键的一部分`（主键可能是两个列组合）。
  * 第三强调非主键列是直接依赖主键，还是直接依赖非主键。

## **2、事务隔离级别有哪些？**
* 有几种现象：
  * 脏读： 一个事务读到了其它没提交的事务的数据！
  * 不可重复读： 一个事务在自己事务期间，多次读的数据，竟然不一致。这是因为别的事务修改了数据，影响到了当前事务。
  * 幻读：范围读的时候，另外的事务在范围内插入了数据，当之前的事务再次范围的时候，比之前多了几行，产生了幻觉，幻读。
* 针对这3个现象搞出4个隔离级别：
  * 读未提交： 所有事务都可以看到其他未提交事务的执行结果。
  * 读已提交： 一个事务只能看见已经提交事务所做的改变。可避免脏读的发生。
  * 可重复读： MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行，解决了不可重复读的问题。
  * 序列化： 最严格，不用多说。

## **3、索引是什么？**
* **为什么B+树比B树更适合实现数据库索引？**
  * 一方面是叶子节点有双向指针，另外一个方面是物理上数据更紧凑，更适合range，可以顺序I/O读出一个范围的数据。
  * 非叶子节点用来做目录页，可以更好的分叉，使得这个树更矮更胖。
* **Hash索引和B+树索引的区别？**
  * hash不支持范围
  * hash不支持模糊，不支持最左原则。
* **索引有什么分类？**
* **什么是聚集索引？**
* **什么是覆盖索引？**

## **4、常见的存储引擎有哪些？**
* MyISAM和InnoDB的区别？

## **5、MVCC 实现原理？**
* MVCC 的实现依赖于版本链，版本链是通过表的三个隐藏字段实现。
* 接下来了解下read view的概念。

## **6、快照读和当前读？**
* 快照读：读取的是快照版本。`普通的SELECT就是快照读`。通过MVCC来进行并发控制的，不用加锁。
* 当前读：读取的是`最新版本`（压根不看mvcc的undo log链条）。`UPDATE、DELETE、INSERT、SELECT … LOCK IN SHARE MODE、SELECT … FOR UPDATE`是当前读。

## **7、那么MySQL如何实现避免幻读？**
* 在快照读情况下，MySQL通过mvcc来避免幻读。
* 在当前读情况下，MySQL通过next-key来避免幻读（`加行锁和间隙锁来实现的`）。
  * 因为它每次都是读最新版本的数据，别的事务插入了数据，它也读到了，所以不加next-key锁的话，就会出现幻读。

## **8、共享锁和排他锁**
* 共享锁：select * from table where id<6 `lock in share mode`;
* 排它锁：select * from table where id<6 `for update`;
  * 申请排他锁的前提是，没有线程对该结果集的任何行数据使用排它锁或者共享锁，否则申请会受到阻塞。
  * 在进行事务操作时，MySQL会对查询结果集的每行数据添加排它锁，其他线程对这些数据的更改或删除操作会被阻塞（只能读操作），直到该语句的事务被commit语句或rollback语句结束为止。
* 排它锁的注意事项：
  * for update 仅适用于Innodb，且必须在事务范围内才能生效。 
  * 根据主键进行查询，查询条件为 like或者不等于，主键字段`产生表锁`。 
  * 根据非索引字段进行查询，name字段`产生表锁`。

## **9、大表怎么优化？**
* 限定数据的范围：比如用户在查询历史信息的时候，可以控制在一个月的时间范围内。 
* 读写分离： 经典的数据库拆分方案，主库负责写，从库负责读。
* 通过分库分表的方式进行优化，主要有垂直拆分和水平拆分：
  * 一个数据库由很多表的构成，每个表对应着不同的业务，`垂直切分是指按照业务将表进行分类`，分布到不同的数据库上面，这样也就将数据或者说压力分担到不同的库上面 。
  * `水平拆分`的典型场景就是大家熟知的分库分表。

## **10、MySQL 执行计划了解吗？**
* explain命令：
  * 表的加载顺序 
  * sql 的查询类型 
  * 可能用到哪些索引，实际上用到哪些索引 
  * 读取的行数

## **11、bin log/redo log/undo log**
* bin log： 
  * 二进制日志（bin log）是MySQL数据库级别的文件，记录对MySQL数据库执行修改的所有操作，不会记录select和show语句，主要用于恢复数据库和同步数据库。
* redo log：
  * 重做日志（redo log）是Innodb引擎级别，用来记录Innodb存储引擎的事务日志，不管事务是否提交都会记录下来，`用于数据恢复`。
  * 当数据库发生故障，InnoDB存储引擎会使用redo log恢复到发生故障前的时刻，以此来保证数据的完整性。将参数innodb_flush_log_at_tx_commit设置为1，那么在执行commit时会将redo log同步写到磁盘。
* undo log：
  * 除了记录redo log外，当进行数据修改时还会记录undo log，undo log用于`数据的撤回操作`，它保留了记录修改前的内容。通过undo log可以实现事务回滚，并且可以根据undo log回溯到某个特定的版本的数据，实现MVCC。
* bin log和redo log有什么区别？
  * bin log会记录所有日志记录，包括innoDB、MyISAM等存储引擎的日志；redo log只记录innoDB自身的`事务日志`。
  * bin log只在事务提交前写入到磁盘，`一个事务只写一次`，一锤定音；而在事务进行过程，会有redo log`不断写入磁盘`。
  * bin log 是逻辑日志，记录的是SQL语句的原始逻辑；redo log 是物理日志，记录的是在某个数据页上做了什么修改。

## **12、讲一下MySQL架构？**
* server层：
  * 连接器： 当客户端连接 MySQL 时，server层会对其进行身份认证和权限校验。
  * 查询缓存: 执行查询语句的时候，会先查询缓存，先校验这个 sql 是否执行过，如果有缓存这个 sql，就会直接返回给客户端，如果没有命中，就会执行后续的操作。
  * 分析器: 没有命中缓存的话，SQL 语句就会经过分析器，主要分为两步，词法分析和语法分析，先看 SQL 语句要做什么，再检查 SQL 语句语法是否正确。
  * 优化器： 优化器对查询进行优化，包括重写查询、决定表的读写顺序以及选择合适的索引等，生成执行计划。
  * 执行器： 首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会根据执行计划去调用引擎的接口，返回结果。
* 引擎层： 
  * 主要负责数据的存储和读取。server 层通过api与存储引擎进行通信。

## **13、分库分表?**
* 垂直分表：
  * 把一张表10列分成一张表5列 + 一张表5列。
  * 优点：
    * 行记录变小，数据页可以存放更多记录，在查询时减少I/O次数。 
  * 缺点： 
    * 主键出现冗余，需要管理冗余列； 
    * 会引起表连接JOIN操作，可以通过在业务服务器上进行join来减少数据库压力； 
    * 依然存在单表数据量过大的问题。
* 水平分表：
  * 对userId这个列进行hash、%64、或者倒数后两位定位等方式去分表。还有mycat等中间件帮忙分表。
  * 优点：
    * 单库（表）的数据量得以减少，提高性能；切分出的表结构相同，程序改动较少。 
  * 缺点：
    * 分片事务一致性难以解决 
    * 跨节点join性能差，逻辑复杂 
    * 数据分片在扩容时需要迁移

## **14、查询语句执行流程？?**
* 权限校验、查询缓存、分析器、优化器、权限校验、执行器、引擎。
* select * from user where id > 1 and name = '大彬';
  * 首先检查权限，没有权限则返回错误； 
  * MySQL以前会查询缓存，缓存命中则直接返回，没有则执行下一步； 
  * 词法分析和语法分析。提取表名、查询条件，检查语法是否有错误； 
  * 两种执行方案，先查 id > 1 还是 name = '大彬'，优化器根据自己的优化算法选择执行效率最好的方案； 
  * 校验权限，有权限就调用数据库引擎接口，返回引擎的执行结果。`（为什么权限校验在最后一步？？？）`

## **15、更新语句执行过程？？?**
* 1、分析器，先查询到 id 为1的记录，有缓存会使用缓存。
* 2、权限校验
* 3、执行器，拿到查询结果，将 name 更新为 大彬，然后调用引擎接口
* 4、引擎
* 5、redo log(prepare 状态)，如果不进入prepare状态直接commit，万一此时断电了，主数据库倒是用redo log恢复数据成功，但是从数据库没有binlog他就不知道这条数据，`主从不同步了`！！
* 6、binlog
* 7、redo log(commit状态)

## **16、exist和in的区别？？？?**
* in 子句： 比如 `select * from A where id in (select id from B)`，是先把子查询的记录放到一个临时表中，再遍历临时表的每一行，带入到外查询条件中。
* exist 子句，比如 `select * from A where id exists (select 1 from B b where A.id=B.id)`， 遍历外表的每一行，带入到内查询中去判断。如果exists 条件为真，则返回外表查询记录，否则丢掉这个外表查询记录。
* 两者的区别：当外表数据量很大的时候，用 in， 因为in是遍历内查询，然后带入到外表中，当内查询数据量很大的时候，用exists，减少大循环的次数。
* 国哥有一个好记的idea：`谁的大循环少，就用谁！`

## **17、MySQL中int(10)和char(10)的区别？**
* int(10)中的10表示的是`显示数据`的长度
* char(10)表示的是`存储数据`的长度。

## **18、truncate、delete与drop区别？?**
* tuncate清空表，delete可以删除更细粒度的数据，drop直接把数据、表结构、约束、索引通通删了。
* 执行速度： drop > truncate > delete，毕竟前两者很无脑。

## **19、having和where区别？**
* `作用对象不同`：having子句作用于组，where子句作用于表和视图。
* `作用时机不同`：having子句要数据分组后过滤，where子句要在数据分组前过滤。

## **20、什么是MySQL主从同步？**
* 就是用一台mysql服务器做Master，其他的服务器做slave，slave会异步从master同步数据过来，最终保持数据一致。
* 为什么要做主从同步？？
  * 一个理由就够了：数据备份，防止单点故障，安全！
  * 读写分离，提高数据库的并发能力。

## **21、乐观锁和悲观锁是什么？？？**
* 悲观锁，顾名思义，很悲观，它假定所有的SQL都会发生并发竞争冲突。所以在查询完数据后把事务锁起来，直到事务提交。mysql innodb怎么实现悲观锁？用锁机制去实现即可。
* 乐观锁，很乐观，假定所有的SQL都不会发生冲突，只有在提交操作时检查数据是否被修改过，所以加一个版本号version，CAS算法。

## **22、用过processlist吗？**
* `show processlist` 或者 `show full processlist` 是用来查看当前MYSQL是否有性能压力命令。
* 主要看它返回的`info`字段表示当前执行的SQL, `state` 字段表示状态：
    * sleep，线程正在等待客户端发送新的请求
    * query，线程正在查询或者正在将结果发送到客户端
    * Sorting result，线程正在对结果集进行排序
    * Locked，线程正在等待锁
* 我记得还有个`show engine innodb status`用来查看死锁的
