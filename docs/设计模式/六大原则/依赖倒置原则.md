# 1、背景
最近在看新项目的代码，着实是头疼呀。

听我细细道来：
* 一个函数要做2，3件事
* 副作用那是必不可少的
* 一个简单的业务，要往下跳3，4个函数调用，期间带着副作用飞来飞去
* 一个service 800行，一个函数200行
* 做了很多过度设计，可能未来半年都不会用到的需求
* hardCode是原罪

但是和他的沟通交流让我皱眉，好像他并没有意识到这么写是不对的。

我在想，国哥是否也是陷入了同样的思维，也许我意识不到自己也是错的？

趁着这个机会，边吐槽项目，边温习下6大设计原则。


# 2、关联
* [六大设计原则之一：单一职责](http://fatpo.github.io/设计模式/六大原则)
* [六大设计原则之一：封闭开放](http://fatpo.github.io/设计模式/六大原则)
* [六大设计原则之一：里式替换](http://fatpo.github.io/设计模式/六大原则)
* [六大设计原则之一：迪米特](http://fatpo.github.io/设计模式/六大原则)
* [六大设计原则之一：依赖倒置](http://fatpo.github.io/设计模式/六大原则)
* [六大设计原则之一：接口隔离](http://fatpo.github.io/设计模式/六大原则)


# 3、依赖倒置
这个依赖倒置通俗来讲，就是让我们写代码依赖接口，而不是依赖具体的实现类。

比如A依赖B，B如果剧烈变化，也会**大概率**导致A跟着剧烈变化，增加了修改代码的成本，违背了封闭开放的原则。

但如果是A和B约定好一个通用的接口C，A调用C的接口，实现类B依赖C接口，这样子，即使B内部变来变去，A**大概率**岿然不动，这才是好设计。

比较官话的版本：
```
1. 模块间的依赖通过抽象发生，实现类之间不直接发生依赖关系，其依赖关系是通过接口或抽象类产生的；

2. 接口或抽象类不依赖于实现类；

3. 实现类依赖接口或抽象类。
```

# 4、小案例
直接上一个符合设计的的demo，司机开车，可以开宝马、奔驰等车，就算宝马倒闭了，司机换个车继续开，不用重新修改司机的源码。

开车的driver：
```java
class Driver{
    void drive(ICar car){
        // 
    }
}
```
司机约定好开车的接口ICar：
```java
interface ICar{
    void baba(){
    }
}
```
第一辆具体的车：
```java
class BMM implements ICar{
    void baba(){
        // 宝马
    }
}
```
第二辆具体车：
```java
class Bz implements ICar{
    void baba(){
        // 奔驰
    }
}
```

# 5、什么是倒置

看到这里相信你也对依赖倒置这个原则有一定的了解了，核心点就是面向接口编程。

但你是否会有一点疑惑，什么是`倒置`？

A依赖B，变成了 A依赖C，B依赖C，这顶多算是依赖转换吧？

其实和我们有相同疑惑的人不少： 
* [博客园](https://q.cnblogs.com/q/72496/)
* [csdn](https://blog.csdn.net/qq_41542638/article/details/105084307)

《设计模式之禅》关于倒置的说法：
```
”讲了这么多，估计大家对“倒置”这个词还是有点不理解，那到底什么是“倒置”呢？
我们先说“正置”是什么意思，依赖正置就是类间的依赖是实实在在的实现类间的依赖，也就是面向实现编程，
这也是正常人的思维方式，我要开奔驰车就依赖奔驰车，我要使用笔记本电脑就直接依赖笔记本电脑。

而编写程序需要的是对现实世界的事物进行抽象，抽象的结果就是有了抽象类和接口，
然后我们根据系统设计的需要产生了抽象间的依赖，
代替了人们传统思维中的事物间的依赖，“倒置”就是从这里产生“。
```

国哥自己的理解：
```
A依赖B，本来必须是先有B，我才能继续开发A。现在定义好接口C后，A和C可以先开发，B过两年再去开发都行，
这个依赖关系不那么明显了。

等等，这只能算是依赖中断，哪里体现依赖倒置了？

也对哦，容国哥想想。
```
国哥的理解2：
```
A依赖B，本来必须是先有B，我才能继续开发A。现在定义好接口C后，A和C可以先开发，B过两年再去开发都行，
这里面要把A和C看成一个整体，C本来就是A规定好的，本来是A依赖B，现在是B依赖A定义的C规范，所以依赖倒置了。

嗯！

我还能举一个例子，tomcat管理调度的一批java app，他们之间肯定也有一个抽象层来管理，我tomcat不管你是什么app，
只要你符合tomcat规定好的抽象规范，你就能被tomcat管理，肯定不能一个java app影响到tomcat的运行吧。

我们把这个tomcat的抽象规范当成C，把tomcat当成A，那些java app就是B。
本来是tomcat要调度各个java app，肯定是依赖着各个java app，
一下子就变成了java app要依赖tomcat的接口规范了。
```

