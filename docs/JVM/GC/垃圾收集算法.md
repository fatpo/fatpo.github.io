## 分代收集理论
很多对象差异性较大，有些朝生夕死，有些长期存在。

本质就是提升回收效率，所以要区别对待，所以分代收集理论应运而生。

新生代，99.9% 的对象要干掉，复制成本很低，而且`据说`复制算法比标记整理和标记清除`快10倍`。
老年代，大概率要留存，`复制成本高，放的对象多`，没办法像复制算法直接空出一半内存来，所以采用标记整理和标记清除。

### 标记复制
把内存`人为`分成2块，有一块永远空着。比如S1和S2。

对不需要GC的对象复制一份到S2，然后把S1都干掉。

很明显效率很高，没有数据移动，复制也是顺序IO，而且如果是99%的死对象都不需要复制，总体复制成本就很低。

缺点也很明显，浪费50%的内存。

### 标记清除
遍历内存对象，然后标记一波。

没被标记到的对象，统统干掉。

简单粗暴，但是问题也很明显，标记对象多的时候，产生大量内存不连续的碎片。


### 标记整理
遍历内存对象，然后标记一波。

把标记好的慢慢挪到内存一端移动。最后清除整理端另一侧边界外的所有内存。

这个解决了标记清除的内存不连续的问题。


### 三者对比
回收效率： 复制 > 整理 > 清除
内存整齐度：复制 = 整理 > 清除
内存利用率：整理 > 清除 > 复制
        
说明都是`据说的`，除了复制算法毋庸置疑外，整理和清除哪个快?

那么清除算法没活路啊。 
        