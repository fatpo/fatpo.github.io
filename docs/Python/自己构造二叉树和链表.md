# 1、背景
写二叉树相关的题目，偶尔确实没思路，想单步调试下。

但苦于本地IDEA没有现成的二叉树的数据，只能自己写一个脚本构造。

写于2022年01月18日。

# 2、创建树脚本
```Python
class TreeNode:
    def __init__(self, val):
        self.val = val
    def set_child(self, left, right):
        self.left = left
        self.right = right

def make_a_tree(data: list):
    n = len(data)
    nodes = [TreeNode(v) if v else None for v in data]
    for i in range(n):
        if nodes[i]:
            left = nodes[2 * i + 1] if 2 * i + 1 < n else None
            right = nodes[2 * i + 2] if 2 * i + 2 < n else None
            nodes[i].set_child(left, right)
    return nodes[0]

def print_tree(root):
    if not root:
        print("None")
        return
    print(root.val)
    print_tree(root.left)
    print_tree(root.right)

def test():
    root = make_a_tree([1,2,3,4,5,6])
    print("#" * 20)
    print_tree(root)
    root = make_a_tree([1,2,3,4,None,None, 5,6])
    print("#" * 20)
    print_tree(root)

if __name__ == '__main__':
    test()
```
思路就是，把它当成满二叉树去处理即可。

# 3、创建链表脚本
```Python
class ListNode:
    def __init__(self, val, next=None)
        self.val = val

def make_a_list(data: list):
    n = len(data)
    head = listNode(0)
    p = head
    nodes = [ListNode(v) if v else None for v in data]
    for i in range(n):
        p.next = nodes[i]
        p = p.next
    return head.next

def print_a_list(root):
    if not root:
        print("None")
        return
    print(root.val)
    print_a_list(root.next)
```