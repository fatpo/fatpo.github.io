## TCP与UDP的区别?
* 面向连接：
    * TCP是一种面向连接的协议。
    * UDP是一种无连接协议。
* 速度：
    * UDP是一种更快更高效更简单的协议，毕竟它都不绝对可靠了，而且也没有`超时重传`、`滑动窗口流量控制`、`拥塞控制`、`延迟应答和捎带应答`等手段。
    * TCP报文头`一般为20字节`，选项最多40字节，限制60字节。UDP报文头`8个字节`，明显UDP小很多，越小越快嘛。
    * 大概率来说，TCP打不过UDP。但速度上面，TCP并不是绝对就比不过UDP吗？
        * 并不是，在某些情况下，TCP 被证实比 UDP 要快。例如，在一个实验中，在一个最大传输单元为 1500 字节的以太网连接上，发送 300 字节的数据包，TCP 比 UDP 大约快 50%。
        * 这是因为 TCP 会`尝试缓存数据`，填充到整个网段，从而`最大化利用了带宽`。而另一边，UDP 立即沿线路发送数据包，这些小数据包很多，堵塞了网络。
* 可靠性：
    * TCP有一整套可靠机制，三次握手，超时重传，ACK应答机制。
    * UDP不可靠。
* 广播：
    * TCP是基于连接的，必须端对端建立好连接后，才能传输。传输结束后必须结束这条连接（四次挥手）。
    * UDP可以广播。    
* 应用场景:
    * TCP 被用于 HTTPS（安全超文本传输协议）、HTTP（超文本传输协议）、SMTP（简单邮件传输协议）、FTP（文件传输协议）等等。
    * UDP 用于视频流、视频电话、IP 语音服务（互联网呼叫）、DNS（域名系统）等。
    
 
## 什么是SYN攻击？
* 背景：linux是怎么维护TCP队列的：
    * 在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：
        * 半连接队列，也称 SYN 队列；
        * 全连接队列，也称 accept 队列；（很幸运的是，linux有个命令可以查看全连接队列`ss`）
* 客户端伪造大量的IP发送SYN包，服务器回复 ACK + SYN 去到一个虚假的`IP地址`，势必会导致服务端存在大量的连接处于`SYN_REVC`状态。
* 服务端的半连接队列大小是有限的，所以被伪造请求挤满后就拒绝其他正常请求。

## 如何应对SYN攻击？
* 1、增大半连接队列的容量:
    * 增大 tcp_max_syn_backlog ，比如提升到1024，之前是256
    * 增大 somaxconn ，比如提升到1024，之前是 128
* 2、打开`tcp_syncookies`功能， syncookies 参数主要有以下三个值：
    * 0 值，表示关闭该功能；
    * 1 值，表示仅当 SYN 半连接队列放不下时，再启用它；
    * 2 值，表示无条件开启功能；
* 3、减少SYN + ACK的重传次数：
    * 设置为1，加速处于`SYN_RECV`状态的连接断开。

## 什么是全连接队列？
* linux是怎么维护TCP队列的：
    * 在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：
        * 半连接队列，也称 SYN 队列；
        * 全连接队列，也称 accept 队列；（很幸运的是，linux有个命令可以查看全连接队列`ss`）
    * 流程如下：
        * 服务端收到客户端发起的 SYN 请求后，内核会把该连接存储到半连接队列，并向客户端响应 SYN+ACK，接着客户端会返回 ACK，服务端收到第三次握手的 ACK 后，内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到 accept 队列，等待进程调用 accept 函数时把连接取出来。
* 如果全连接队列满了：
    * 配置内核参数： tcp_abort_on_overflow 共有两个值分别是 0 和 1，其分别表示：
        * 0 ：如果全连接队列满了，那么 server 扔掉 client 发过来的 ack ； （默认是0，客户端会多次重发，`万一有一次遇到了队列有空位就创建成功啦`，有利用提高连接的创建成功率）
        * 1 ：如果全连接队列满了，server 发送一个 reset 包给 client，表示废掉这个握手过程和这个连接；
* 如何增大 TCP 全连接队列呢？:
    * TCP 全连接队列的最大值取决于 somaxconn 和 backlog 之间的最小值，也就是 min(somaxconn, backlog)， 而 somaxconn=128，所以只能有128个。

## TCP超时重传时间怎么计算的？
* 背景：TCP具有超时重传的机制。时间叫：Retransmission Timeout，简称RTO。
    * RTO太小，会导致很多不必要的重传。
    * RTO太大，会导致丢包很久了才重传。
    * 不好计算啊！
* 那么TCP怎么计算的呢？
    * 什么是往返时延：Round-Trip Time，简称RTT。
    * 取平均值：第一次RTT是500ms，第二次RTT是700ms，那么我们就把RTO = (500+700)/2 = 650 ms
    * `平滑往返时间`： SRTT，每测量一次RTT，就对SRTT做一次更新计算。`平滑因子0.8`什么的。

## 能不能说一下TCP的流量控制？
* 流量控制的背景：无论是发送端还是接收端，在收发数据的时候，都有2个缓冲区：`发送缓冲区、接收缓冲区`
* 流量控制的目的：在对方的接收缓冲区满了的情况下，不要继续发送啦。
* 流量控制的实现：
    * 1、接收端会告知发送端，自己的接收窗口`rwnd`，也就是接收缓冲区中空闲的部分。
    * 2、`ACK确认`的时候，会带上窗口大小rwnd。
* 发送端的数据包的4种状态：
    * 已发送并且已确认
    * 已发送但未确认
    * 未发送但接收端可以接收（接收端有空闲空间）
    * 未发送且不可以发送（接收端没有空闲空间）
* 什么是发送窗口：（想象一下滑动窗口）
    * 包含： `已发送但未确认` + `未发送但接收端可以接收` 两种数据包的一个逻辑窗口
    * 滑动： 当`已发送未确认` -> `已发送已确认`， 那么窗口会往前蠕动
* 发送速度较慢：那么窗口就包含： `已发送但未确认` + `未发送但接收端可以接收`
* 发送速度较快：那么窗口就只包含： `已发送但未确认` 。

## 能不能讲一下TCP的拥塞控制？
* 背景: 虽然TCP已经有`滑动窗口`大杀器了，可以高效可靠发送大量的数据。但是在刚开始阶段就发送大量的数据，可能会引发问题，比如当前网络比较拥挤，我们在不清楚网络状态的情况下贸然发送大量数据，可能`雪上加霜`。
* 慢启动：TCP引入了慢启动机制，先发少量的数据探探路，摸清网络拥堵状态后再决定按照多大的速度传输数据。
*`拥塞窗口`： 初始size=1，每次收到一个ACK应答，size ++, 每次发送数据包的时候，min(拥塞窗口size， ACK反馈的滑动窗口size)，作为实际发送窗口。
* 慢启动阈值：当慢启动阈值==窗口最大值时，每次超时重发，慢启动阈值就会变成原来的一半，通知拥塞窗口size=1。

## 能不能讲一下延迟应答？
* 背景：
    * 首先要知道接收端有个缓冲区，你ACK应答的时候，缓冲区剩余空间，就是滑动窗口的大小。
    * 如果接收完数据后立刻应答，缓冲区可能只消费了30%，只有30%的空闲区间，窗口值比较小。
    * 如果过20ms再去ACK应答，缓冲区可能消费了50%，那么就有50%的空闲区间，窗口值在变大。
    * 如果过100ms再去ACK应答，缓冲区可能消费了100%啦，没数据啦，有100%的空闲区间，窗口值是max！！！（`窗口值越大，吞吐越大，传输效率越高`）
* 延迟应答：
    人为放缓ACK应答时间，进而提升ACK窗口值，进而提升TCP的传输吞吐量。  
* 防止滥用：
    * 数量限制：每N个包就必须马上应答一次。一般N=2。
    * 时间限制：超过最大延迟时间必须马上应答一次，一般200ms。

## 为什么TCP有一个定时器每隔200ms来判断是否要发送ACK包？
* 1、ACK可以合并，如果我短时间内接手了3，4个TCP包，我不一定要回复3，4个ACK应答包，我可以回复最终的ACK包即可，降低了网络流量。
* 2、如果接收方有数据要发送，可以顺路`捎带应答`，可以避免大量的ACK应答包以一个单独的TCP包发送，减少了网络流量。

## 什么是捎带应答？
* 要先说明什么是ACK应答?
    * 根据TCP协议，端对端的可靠性，必须要应答包来确保数据包的收到。
* 什么是捎带应答？
    * 就是尽可能不要单独发送ACK应答包，看看有没有正要发送的数据包，顺路带着即可。它也算是`延迟应答`的直接受益者。

## 能不能说一下TCP的keep alive机制？
* 7200s 没有数据包交互才会发送keepalive探测包，不过2小时实在是太久了。
* 应用层比如kafka、zk、mysql等都是通过自己的心跳机制去判断对端是否挂了。

## 讲讲TCP的端口号？
* 熟悉的端口号：80，443，22，3306，6379
* 已登记的端口号：

## TCP场景问题
* AB两个主机之间建立了TCP连接，A主机给B主机发送了2个TCP报文，大小分别为500，300，第一个报文序列号是200，那么B主机接收两个报文后，应该返回的确认号是多少？
    * ACK = 初始的200+500+300 = 1000，意思是下一个序列号请从1000开始。 
* 收到IP数据包解析以后，它怎么知道这个分组应该投递到上层的哪一个协议呢？是UDP还是TCP呢？
    * IP报文头有一个字段叫：协议，8位， ICMP = 1 , TCP = 6, UDP = 17。
* TCP提供的是一种字节流服务，而收发双发都不保持记录的边界，应用程序应该如何提供他们自己的记录标记呢？
    * 应用程序没这么蠢啦，虽然TCP没有边界概念，但是应用层可以自己规定边界嘛，比如/r/n表示一条记录的换行边界，比如Redis通信协议(RESP protocal)也有边界的概念在里面。