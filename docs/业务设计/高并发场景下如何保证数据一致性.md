## 1、场景分析
面试官：你们服务器QPS多少？

回答：访问量还挺高的，高峰期3W QPS吧。

面试官：这么高的访问量，你们服务器扛得住吗，有没有缓存？

回答：有的，用了redis，先查redis，查不到再查DB，减少数据库的访问压力，也加快了查询效率。

面试官：一份数据存储多个地方，更新数据的时候，你们怎么保证数据一致性的？

## 2、解决方案

缓存与数据库的先后关系，无非是4种可能性：
* 先更新缓存，再更新数据库
* 先更新数据库，再更新缓存
* 先删除缓存，再更新数据库
* 先更新数据库，再删除缓存

ps：
```dtd
我们默认操作缓存比操作DB要快得多，如果两个请求同时到来，也是两个请求的缓存操作步骤 快于 两个请求的数据库操作步骤。
```

### 2.1 先更新Redis再更新DB
```dtd
请求1：更新了Redis = 1
请求2：更新了Redis = 2
请求1：更新了DB = 1
请求2：更新了DB = 2 
```
这个情况没问题，redis和DB都是2。

```dtd
请求1：更新了Redis = 1
请求2：更新了Redis = 2
请求2：更新了DB = 2 
请求1：更新了DB = 1
```
这个情况就有问题了，redis是2，DB是1。

`所以这个解决方案pass。`

### 2.2 先更新DB再更新Redis
```dtd
请求1：更新了DB = 1
请求2：更新了DB = 2 
请求1：更新了Redis = 1
请求2：更新了Redis = 2
```
这个情况没问题，redis和DB都是2。

```dtd
请求1：更新了DB = 1
请求2：更新了DB = 2 
请求1：更新了Redis = 2
请求2：更新了Redis = 1
```
这个情况就有问题了，redis是1，DB是2。

所以这个解决方案pass。

### 2.3 先删除Redis再更新DB
```dtd
请求1：删除Redis
请求2：删除Redis 
请求3：查不到Redis，就从DB查出oldValue设置到Redis中
请求1：更新了DB = 1
请求2：更新了DB = 2
```
好像不大行，删除缓存但是还没更新DB的时候，如果有读请求（读请求很频繁的），会把旧数据刷入缓存。
更可怕的是，如果下次更新数据库是`6小时后`，那么这期间的6小时，DB与redis一直是不一致的。


`所以这个解决方案pass。`

### 2.4 先更新DB再删除Redis
```dtd
请求1：更新了DB = 1
请求2：更新了DB = 2
请求3：因为redis有oldValue，返回，下一秒就被删除了，只是短暂的不一致
请求1：删除Redis
请求2：删除Redis 
```
这个问题：
```dtd
请求1：（前半部分）读请求发现Redis没数据，查询数据库
请求2：写请求更新DB，删除Redis
请求1：（后半部分）写回Redis
```
但是这个情况太极端了，因为操作缓存是远比操作数据库快的，如果非要考虑这个情况，可以加一个expire。

`所以这个解决方案accept！`
